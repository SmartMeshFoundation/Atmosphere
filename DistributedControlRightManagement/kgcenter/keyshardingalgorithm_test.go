package kgcenter

import "testing"

/*
小费马定理：
假如p是质数，且gcd(a,p)=1，那么 a(p-1)≡1（mod p），
例如：假如a是整数，p是质数，则a,p显然互质(即两者只有一个公约数1)，
那么我们可以得到费马小定理的一个特例，即当p为质数时候， a^(p-1)≡1(mod p)。

椭圆曲线加密解密原理：
A：椭圆曲线：
1、椭圆曲线可以用二元三阶方程来表述,即y^2=a+bx+cx^2+d^3(a/b/c/d为系数)
2、其理想化的形状可以表述为（当然不一定关于x轴对称）：
						^y
						|
						|           *
				   *	|		  *C'
				*	  * | B     *
			   *	   *| *	* *
			 A*			|
---------------------------------------------------x
			  *	A'		|
			   *	   *| * * *
 				*     * |        *
				   *   	|          *C
						|            *
据图给定4种运算：
	add运算:过A、B点的直线必须与C'点相交，定义相交点关于对称轴在曲线上的点为C点(C=A+B)，
	mul运算：如果有A点与曲线只有C',即A点为一个切点，做切线与曲线相交C‘,对称点C(C=A+A，C=2A)，就出现了二倍运算
	正负取反运算：A关于对称轴的点A'（-A）
	无穷远点：过A和A'的直线平行于Y轴，认为该直线与椭圆曲线相交与无穷远点，当然在椭圆加密上必须存在这个无穷（bigint）远点
B：加密原理
1、抽象一下：如果给点了一个点G，5×G，8×G（xG）是可以计算出来的，xG（乘成什么样可以理解为斜率是因子）也是一个点，但是如果给出点y（y=xG）,
			求出x就很麻烦，去猜测(遍历?)a/b/c/d来配x吧
C：加密运算和离散点的来源：
1、曲线是点构成的，即实数域，那个就过分了，无穷无尽，根据数论上的说法，定义某个质数p,p指向有限域GF，即可GF(mod p)就表示（0\1\2\3...p-1）
   组合成的整数集合（离散点），原始的椭圆曲线方程就是这些集合中的元素的加减乘除运算，比如曲线y^2=1+x+x^3(mod 23),当x=1,y=7,那么49=1+1+1（mod 23）,
    当x=4,y=0,那么0=1+4+64(mod 23)
   备注：根据C运算规定的优先级，防止超过精度，
		乘法：(a*b)%c = (a%c)*(b%c)%c，
		加法：(a+b)%c =( (a%c)+(b%c) )%c
		除法：(a/b)%c 费马定理变成乘法
   根据离散点的构成原理，那么理解s256就比较简单了:
   secp256k1.S256.BitCurve{
	P       *big.Int //GF(mod p)中的p,有限域中的质数
	N       *big.Int //G点的阶，如果存在最小正整数n,使得nG=无穷远的交点，n则是G的阶
	B       *big.Int //椭圆曲线方程中的常数（比如A点中的a）
	Gx, Gy  *big.Int //G点 G(x,y),这里x,y对应曲线方程中的x,y,也可以理解为坐标（没连续曲线了，离散点也叫坐标）
	BitSize int      //密钥长度
	}其中：
		ScalarBaseMult=k*G,所以结果是Gx,Gy
     	ScalarMult=k*(Bx,By)
		IsOnCurve(x,y *big.Int)是否在曲线上，即瞒住曲线方程

2、根据公式，已知G，xG，让求x很困难，定义：x为私钥,xG为公钥
3、如果定义K为私钥，K=kG(G为G点，k为私钥)
   加密：选择随机数r,将消息生成密文C，即密文是个点对C={rG,M+rK}
   解密：M + rK - k(rG) = M + r(kG) - k(rG) = M
  也就是说：alice选择椭圆曲线来加密(比如算法ECDSA)，设私钥、公钥分别为k、K，即K = kG，其中G为G点,h为消息的hash值
	alice选择了个r(随机数),计算点rG(x,y)
`	alice计算出一个s， s=(hash(消息M)+kx)/r -->s=(h+kx)r
    alice讲消息M、签名{rG,s}发送给bob
    bob收到了alice发过来的消息M、签名{rG(x,y),s}
    bob根据消息M,求得一个h=hash(M)
    bob根据alice发过来的公钥K，计算hG/s+xK/s,其结果与rG比较，相等表示bob收到的确实是alice来的
     hG/s+xK/s
   = hG/s+x(kG)/s
   = (h+xk)G/s
   = (h+xk)G/((h+kx)/r)
   = r(h+xk)G/(h+kx)
   = rG
*/
func TestKeyGenerate(t *testing.T) {

}
